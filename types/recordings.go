package types

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"

	"github.com/olekukonko/tablewriter"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
)

const (
	RecordListURI = "axis-cgi/record/list.cgi"
	EventID       = "ACC_Motion2"
)

func clockMinutes(t time.Time) int {
	h, m, _ := t.Clock()
	return h*60 + m
}

/////////////////////////////////////////////////////////////////
//Code generated by chidley https://github.com/gnewton/chidley //
/////////////////////////////////////////////////////////////////

type Recording struct {
	XMLName         xml.Name `xml:"recording,omitempty" json:"recording,omitempty"`
	DiskID          string   `xml:"diskid,attr"  json:",omitempty"`
	EventID         string   `xml:"eventid,attr"  json:",omitempty"`
	EventTrigger    string   `xml:"eventtrigger,attr"  json:",omitempty"`
	Locked          string   `xml:"locked,attr"  json:",omitempty"`
	RecordingID     string   `xml:"recordingid,attr"  json:",omitempty"`
	RecordingStatus string   `xml:"recordingstatus,attr"  json:",omitempty"`
	RecordingType   string   `xml:"recordingtype,attr"  json:",omitempty"`
	Source          string   `xml:"source,attr"  json:",omitempty"`
	StartTime       string   `xml:"starttime,attr"  json:",omitempty"`
	StartTimeLocal  string   `xml:"starttimelocal,attr"  json:",omitempty"`
	StopTime        string   `xml:"stoptime,attr"  json:",omitempty"`
	StopTimeLocal   string   `xml:"stoptimelocal,attr"  json:",omitempty"`
	Video           *Video   `xml:"video,omitempty" json:"video,omitempty"`
}

func (r *Recording) String() string {
	return fmt.Sprintf("%s - %s", r.StartTimeLocal, r.StopTimeLocal)
}

func (r *Recording) Filter(maxLength string, daytime bool, sunrise, sunset string) (bool, error) {
	// No stop time. Still recording.
	if r.StopTimeLocal == "" {
		if viper.GetBool("verbose") {
			fmt.Printf("%s has no stop time\n", r.StartTimeLocal)
		}
		return true, nil
	}

	// Max length
	if maxLength != "" {
		start, err := time.Parse(time.RFC3339, r.StartTimeLocal)
		if err != nil {
			return true, errors.Wrap(err, "could not parse start time")
		}
		stop, err := time.Parse(time.RFC3339, r.StopTimeLocal)
		if err != nil {
			return true, errors.Wrap(err, "could not parse stop time")
		}

		duration := stop.Sub(start).Truncate(time.Second)
		if viper.GetBool("verbose") {
			fmt.Printf("%s checking duration: %s...", r.StartTimeLocal, duration)
		}
		maxDuration, err := time.ParseDuration(maxLength)
		if err != nil {
			return true, errors.Wrap(err, "could not parse max length")
		}
		if duration > maxDuration {
			if viper.GetBool("verbose") {
				fmt.Printf("too long (>%s)\n", maxDuration)
			}
			return true, nil
		}
		if viper.GetBool("verbose") {
			fmt.Println("ok")
		}
	}

	// Daytime only
	if daytime {
		start, err := time.Parse(time.RFC3339, r.StartTimeLocal)
		if err != nil {
			return true, errors.Wrap(err, "could not parse start time")
		}
		after, err := time.Parse(time.Kitchen, sunrise)
		if err != nil {
			return true, errors.Wrap(err, "could not parse sunrise")
		}
		before, err := time.Parse(time.Kitchen, sunset)
		if err != nil {
			return true, errors.Wrap(err, "could not parse sunset")
		}

		if clockMinutes(start) < clockMinutes(after) || clockMinutes(start) > clockMinutes(before) {
			if viper.GetBool("verbose") {
				fmt.Printf("%s outside of daylight hours\n", r.StartTimeLocal)
			}
			return true, nil
		}
	}

	return false, nil
}

type Recordings struct {
	XMLName                 xml.Name     `xml:"recordings,omitempty" json:"recordings,omitempty"`
	NumberOfRecordings      string       `xml:"numberofrecordings,attr"  json:",omitempty"`
	TotalNumberOfRecordings string       `xml:"totalnumberofrecordings,attr"  json:",omitempty"`
	Recording               []*Recording `xml:"recording,omitempty" json:"recording,omitempty"`
}

func (recordings *Recordings) String() string {
	output := new(bytes.Buffer)
	table := tablewriter.NewWriter(output)
	table.SetHeader([]string{"ID", "StartTime", "StopTime"})

	for _, r := range recordings.Recording {
		table.Append([]string{r.RecordingID, r.StartTimeLocal, r.StopTimeLocal})
	}
	table.Render()
	return output.String()
}

type RecordingsRoot struct {
	XMLName                           xml.Name    `xml:"root,omitempty" json:"root,omitempty"`
	XsiSpacenoNamespaceSchemaLocation string      `xml:"http://www.w3.org/2001/XMLSchema-instance noNamespaceSchemaLocation,attr"  json:",omitempty"`
	Xmlnsxsi                          string      `xml:"xmlns xsi,attr"  json:",omitempty"`
	Recordings                        *Recordings `xml:"recordings,omitempty" json:"recordings,omitempty"`
}

type Video struct {
	XMLName    xml.Name `xml:"video,omitempty" json:"video,omitempty"`
	FrameRate  string   `xml:"framerate,attr"  json:",omitempty"`
	MimeType   string   `xml:"mimetype,attr"  json:",omitempty"`
	Height     int      `xml:"height,attr"  json:",omitempty"`
	Resolution string   `xml:"resolution,attr"  json:",omitempty"`
	Width      int      `xml:"width,attr"  json:",omitempty"`
}

// getRecordingsList calls the server API and parses the XML response
func GetRecordings(host string) (*Recordings, error) {
	v := url.Values{}
	// v.Set("maxnumberofresults", "20")
	v.Set("recordingid", "all")
	v.Set("eventid", EventID)
	v.Set("sortorder", "descending")
	//v.Set("aftertime", "2018-05-16T15:00:00Z")

	resp, err := http.Get(fmt.Sprintf("http://%s/%s?%s", host, RecordListURI, v.Encode()))
	if err != nil {
		return &Recordings{}, errors.Wrap(err, "HTTP error")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	var root RecordingsRoot
	xml.Unmarshal(body, &root)

	return root.Recordings, nil
}
